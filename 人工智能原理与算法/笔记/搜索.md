问题求解，首先要讨论的是==对问题及其解的精确定义==，接着介绍==求解此类问题通用的搜索算法==。首先是==无信息的(uninformed)搜索算法==--无信息是指算法除了问题定义本身没有任何其他信息，==此类算法效率都不好==；另一方面是==有信息的搜索算法==，==利用给定的知识引导能更有效地找到解==

本章，我们简化任务环境，限定问题的解是一组有固定顺序的行动。

[TOC]

## 问题求解

### 问题求解的假设和概念

寻找达到目标的行动序列的过程被称为==搜索==，搜索算法输入：问题，输出：行动序列形式的解。解找到后，就会付诸实施，即==执行阶段==。那么便完成了对agent的简单设计：“形式化、搜索、执行”，如图3-1所示。

在完成对目标和待求解问题的形式化之后，==agent调用搜索过程进行问题求解==，然后agent按照问题求解给出的解步骤逐一实施-通常是执行序列中的第一个行动-==从序列中删除已完成的步骤==。一旦解被执行，agent将形式化新的目标。

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\简单问题求解agent.PNG" style="zoom:50%;" />

搜索的路径 是==状态序列==，寻找从初始状态到目标状态的路径。

检索：静态

搜索：动态生成

搜索策略：

- 不可撤回的控制策略 例子：八数码问题
- 试探性的控制策略：
  - 回溯型   例子:四皇后问题
  - 图搜索

## 回溯式搜索

回溯是控制策略的一种方法。选择一条规则，如果不能得出一个解，那么**==忘掉==**参与的各步骤，并选择另一条规则代之。从形式上看不管有多少知识对选择规则有用，都可采用回溯的策略。

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\四皇后.PNG" style="zoom:50%;" />

定义左上角的位置为(1,1),然后第一个皇后放在(1,1),那么第二个皇后可以放在(2,3)，然后没位置放了，然后回溯到(1,1)，将第二个皇后放到(2，4)...;然后将第一个皇后放到(1,2)，之后便可顺利地将四个皇后放到对应位置。

### 回溯搜索算法

**#**一个简单的递归过程抓住了回溯控制下的产生式系统的运行本质，这个递归过程叫做BACKTRACK
**#**DATA为==自变量/当前状态==，最初设置为==产生式系统的综合数据库==。在过程结束时，返回==一张规则表==（**从当前状态到目标状的路径**）。这张表如果依次应用于初始数据库，则产生一个满足结束条件的数据。如果==过程找不到规则表就返回FAIL（失败）==。

```伪代码
BACKTRACK(DATA)  
	IF Term(DATA) RETURN NIL; 
	IF Deadend(DATA) RETURN FAIL; 
	RULES:=Apprules(DATA); 
LOOP: IF Null(Rules) RETURN FAIL; 
	R:=First(Rules);
	RUles:=Tail(Rules);
	Rdata:=Gen(R,DATA);
	Path:=BACKTRACK(Rdata);
	IF Path=FAIL GO LOOP;
	Else RETURN Cons(R,Path);
```

```伪代码
BACKTRACK(DATA)  ###注：“:”就看作箭头就好了
	IF Term(DATA) RETURN NIL; ##TERM：找目标，对满足产生式系统结束条件变量来说取值为真。在成功结束时，返回空表NIL
	IF Deadend(DATA) RETURN FAIL; ##状态不合法，无法继续搜索，返回FAIL  或 对已经知道不在一条解路上的自变量来说取值为真。在这种情况下，过程返回符号FAIL
	RULES:=Apprules(DATA); ##Apprules是一个函数，它计算可应用于其自变量的规则并排列这些规则（任意排列或者按照启发式准则排列）
LOOP: IF Null(Rules) RETURN FAIL; ## 如果不再有可应用的规则，那么过程失败。
	R:=First(Rules);  ##选出最好的一条可用规则
	RUles:=Tail(Rules);  ##删去刚才选用的一条规则，缩小可应用的规则表
	Rdata:=Gen(R,DATA); ##应用规则R产生一个新的数据库
	Path:=BACKTRACK(Rdata); ##在新数据库上递归调用BACKTRACK
	IF Path=FAIL GO LOOP;  ##若递归调用失败，则试另一条规则
	Else RETURN Cons(R,Path); ##否则，把R加到表的前面，向上走一遍成功的规则表。 或 获取解路径规则表
```

### 存在问题及解决办法

#### 问题：

- ==深度问题==：如果深度太深
- ==死循环问题==：如果状态出现重复

#### 解决办法：

- 对搜索深度加以限制，超出这个深度，任何递归调用均失败
- 记录从初始状态到当前状态的路径，并不断检验新的路径，看是否和记录的路径吻合。

#### 修正后的回溯搜索算法

```伪代码
BACKTRACK1(DATALIST)  
	IF Term(DATA) RETURN NIL; 
	IF Deadend(DATA) RETURN FAIL; 
	RULES:=Apprules(DATA); 
LOOP: IF Null(Rules) RETURN FAIL; 
	R:=First(Rules);
	RUles:=Tail(Rules);
	Rdata:=Gen(R,DATA);
	Path:=BACKTRACK(Rdata);
	IF Path=FAIL GO LOOP;
	Else RETURN Cons(R,Path);
```



## 图搜索策略



## 无信息搜索



## 启发式搜索



## A*算法与性质















Datalist  从初始状态到当前状态

修正的：
5.限制深度（和最大值相比较）

11.将生成的DATAlist加到原来的？



图搜索策略

回溯：放弃的状态永远放弃

图搜索：放弃的状态可能再用

回溯搜索：只保留从初始状态到当前状态的一种路径

图搜索：保存所有搜索过的路径

节点深度，限制搜索深度，



图搜索算法：

如何搜索，

能生成搜索图和搜索树





f(n)最小的排到最前面

走过的函数是$g^{*}(n)$,



最优路径可以是一条或多条



