问题求解，首先要讨论的是==对问题及其解的精确定义==，接着介绍==求解此类问题通用的搜索算法==。首先是==无信息的(uninformed)搜索算法==--无信息是指算法除了问题定义本身没有任何其他信息，==此类算法效率都不好==；另一方面是==有信息的搜索算法==，==利用给定的知识引导能更有效地找到解==

本章，我们简化任务环境，限定问题的解是一组有固定顺序的行动。

[TOC]

## 问题求解

### 问题求解的假设和概念

寻找达到目标的行动序列的过程被称为==搜索==，搜索算法输入：问题，输出：行动序列形式的解。解找到后，就会付诸实施，即==执行阶段==。那么便完成了对agent的简单设计：“形式化、搜索、执行”，如图3-1所示。

在完成对目标和待求解问题的形式化之后，==agent调用搜索过程进行问题求解==，然后agent按照问题求解给出的解步骤逐一实施-通常是执行序列中的第一个行动-==从序列中删除已完成的步骤==。一旦解被执行，agent将形式化新的目标。

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\简单问题求解agent.PNG" style="zoom:50%;" />

搜索的路径 是==状态序列==，寻找从初始状态到目标状态的路径。

检索：静态

搜索：动态生成

搜索策略：

- 不可撤回的控制策略 例子：八数码问题
- 试探性的控制策略：
  - 回溯型   例子:四皇后问题
  - 图搜索

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\八数码_f减小方向.jpg" style="zoom:50%;" />

八数码问题,f代表与正确的排列方式之间不同数字的个数.我们进行搜索的话,是沿着让f减小的方向进行的.

## 回溯式搜索

回溯是控制策略的一种方法。选择一条规则，如果不能得出一个解，那么**==忘掉==**参与的各步骤，并选择另一条规则代之。从形式上看不管有多少知识对选择规则有用，都可采用回溯的策略。

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\四皇后.PNG" style="zoom:50%;" />

定义左上角的位置为(1,1),然后第一个皇后放在(1,1),那么第二个皇后可以放在(2,3)，然后没位置放了，然后回溯到(1,1)，将第二个皇后放到(2，4)...;然后将第一个皇后放到(1,2)，之后便可顺利地将四个皇后放到对应位置。

### 回溯搜索算法

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\回溯算法-递归过程说明.PNG" style="zoom:67%;" />

**#**一个简单的递归过程抓住了回溯控制下的产生式系统的运行本质，这个递归过程叫做BACKTRACK
**#**DATA为==自变量/当前状态==，最初设置为==产生式系统的综合数据库==。在过程结束时，返回==一张规则表==（**从当前状态到目标状的路径**）。这张表如果依次应用于初始数据库，则产生一个满足结束条件的数据。如果==过程找不到规则表就返回FAIL（失败）==。

#如果成功,返回一条包含R的路径(Ri1,Ri2...Rin)

```伪代码
BACKTRACK(DATA)  
	IF Term(DATA) RETURN NIL; 
	IF Deadend(DATA) RETURN FAIL; 
	RULES:=Apprules(DATA); 
LOOP: IF Null(Rules) RETURN FAIL; 
	R:=First(Rules);
	RUles:=Tail(Rules);
	Rdata:=Gen(R,DATA);
	Path:=BACKTRACK(Rdata);
	IF Path=FAIL GO LOOP;
	Else RETURN Cons(R,Path);
```

```伪代码
BACKTRACK(DATA)  ###注：“:”就看作箭头就好了
	IF Term(DATA) RETURN NIL; ##叶节点,返回NILTERM：找目标，对满足产生式系统结束条件变量来说取值为真。在成功结束时，返回空表NIL
	IF Deadend(DATA) RETURN FAIL; ##状态不合法，无法继续搜索，返回FAIL  或 对已经知道不在一条解路上的自变量来说取值为真。在这种情况下，过程返回符号FAIL
	RULES:=Apprules(DATA); ##Apprules是一个函数，它计算可应用于其自变量的规则并排列这些规则（任意排列或者按照启发式准则排列）
LOOP: IF Null(Rules) RETURN FAIL; ## 如果不再有可应用的规则，那么过程失败。
	R:=First(Rules);  ##选出最好的一条可用规则
	RUles:=Tail(Rules);  ##删去刚才选用的一条规则，缩小可应用的规则表
	Rdata:=Gen(R,DATA); ##应用规则R产生一个新的数据库
	Path:=BACKTRACK(Rdata); ##在新数据库上递归调用BACKTRACK
	IF Path=FAIL GO LOOP;  ##若递归调用失败，则试另一条规则
	Else RETURN Cons(R,Path); ##否则，把R加到表的前面，向上走一遍成功的规则表。 或 获取解路径规则表；　　　中间节点，返回包含R的路径
```

### 存在问题及解决办法

#### 问题：

- ==深度问题==：深度太深,对深度加以限制
- ==死循环问题==：如果状态出现重复,:A→B,B→C,C→A

#### 解决办法：

- 对搜索深度加以限制，超出这个深度，任何递归调用均失败
- 记录从初始状态到当前状态的路径，并不断检验新的路径，看是否和记录的路径吻合。

#### 修正后的回溯搜索算法

##DATALIST：从初始到当前的状态表（逆向）

##返回值：从==当前状态到目标状态的路径==（以==规则表==的形式表示）或FAIL

```伪代码
BACKTRACK1(DATALIST) ##状态序列表
	DATA:=FIRST(DATALIST)  ##DATALIST中的第一个元素赋给DATA
	IF MEMBER(DATA,TAIL(DATALIST)) ##新增 判断DATA是否为DATALIST中的一个元素(已经将DATALIST中的第一个元素删去)
	RETURN FAIL;   ##新增　如果重复,则返回失败(防止重复), 回老路退回
	IF Term(DATA) RETURN NIL;  ##到达目的.退回
	IF Deadend(DATA) RETURN FAIL;  ##不合理状态,退回
    IF Length(DATALIST)>BOUND  ##新增  
    RETURN FAIL;   ##新增  到达深度限制,退回
	RULES:=Apprules(DATA);  ##得出可应用的规则集
LOOP: IF Null(Rules) RETURN FAIL;  ##进入死胡同,退回
	R:=First(Rules); ##取出第一条可运用规则
	Rules:=Tail(Rules); 
	Rdata:=Gen(R,DATA); ##运用规则,生成新状态
	RDATALIST:=Cons(RDATA,DATALIST);  #新增  将RDATA新增在DATALIST的前部
	Path:=BACKTRACK1(RDATALIST);   ##递归
	IF Path=FAIL GO LOOP;
	RETURN Cons(R,Path);
```

## 图搜索策略

图搜索策略就是在图中寻找从起始点到目标点的路径的方法.

- 问题的引出:

  ->八皇后问题/找最短路径

- 回溯与图搜索的区别:

  ->回溯:放弃的状态永远放弃;

  ->图搜索:放弃的状态以后还可能再用

- 算法:

  ->回溯搜索:只保留从==初始状态==到==当前状态==的**一条路径**.

  ->图搜索:保留==所有==已经搜索过的路径

- 图搜索一般过程

  ->即为构造搜索图的过程.令搜索图开始时只有起始点S0,然后逐步扩展节点,直到将目标节点扩展到搜索图里为止. 扩展的过程就是搜索的过程.

  ->扩展节点方法不同,意味着搜索的方法不同,也就是搜索的路径不同.

- ==**扩展一个节点**==

  ->生成出该节点的所有后继节点,并给它们之间的**代价值**.这一过程称为"扩展一个节点"

- 路径

  ->设一节点序列为(n0,n1...nk),对于i=1,2,...k,若节点$n_{i-1}$有一个后继节点ni,则程为从n0→nk的路径.

- 路径的代价值

  ->一条路径的代价值等于连接这条路径各节点间所有代价值的综合.

- 节点深度

  ->根节点深度为0,其他节点深度=父节点深度+1

### 图搜索的思路

- ==**OPEN 表**==

  ->存放已经生成但未扩展的节点

- ==**CLOSED表**==

  ->存放已经扩展的节点

- 扩展节点i生成节点j

- 指针

- 调整指针

#### 图搜索例子

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\图搜索例子.PNG" style="zoom:50%;" />

{1,2,3}→{2,1,3}是进行了一次排序

#### 图搜索一般流程

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\图搜索流程.PNG" style="zoom:50%;" />

==**PPT中,为什么13这个节点在open表中,但是仍有10这个节点指向它的指针呢?**==

我的理解:如果扩展了节点13,那么它的子节点就会有14和10,此时,由于节点10已经指向了8,那么就要调整指针,这个时候将13退回未扩展节点时的状态,并调整10的指针,指向13,此时它们两个仍都是未扩展节点(==那为什么13仍有一个子节点14呢?==)  ==那8到2的指针调整又该怎么理解呢?==(由于8已经在closed表中了吗?)

26页→27页,8的指针调整到了指向2,在上面的流程中:"并决定是否调整它们在G中后裔的指针",10和11是8的后裔,要将10的指针重新调整指向8(==是这样吗?==)

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\图搜索算法说明.jpg" style="zoom:50%;" />

## 无信息搜索

### 无信息图搜索/盲目搜索

对节点的排序不适用与问题相关的信息, 实际上是对解空间的遍历

#### 深度有限搜索

->不同的节点,==深度越大==,在OPEN表中==越靠前==,首先扩展最新产生的节点(==一条道走到黑==)

->深度相同,任意排序;

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\深度有限搜索-注.PNG" style="zoom:50%;" />

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\深度有限搜索-例.PNG" style="zoom:50%;" />

#### 宽度有限搜索

不同的节点,==深度越小==,在OPEN表中==越靠前==,在对下一层搜索前,必须搜索完本层的所有节点

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\宽度有限搜索-注.PNG" style="zoom:50%;" />

(单位代价值/单位耗散值)

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\宽度有限搜索-例.PNG" style="zoom:50%;" />

## 启发式搜索

无信息搜索一般需要产生大量的节点,因而效率较低

- 启发式信息

  ->为了提高效率,使用问题相关信息,以减少搜索量(联想),这些信息即为启发式信息

- 启发式搜索

  ->使用启发式信息的搜索

  ->启发式图搜索:对节点排序

- 启发式信息的强度

  ->强:搜索量降低,但可能找不到最优解

  ->若:工作量较大,极限时为盲目搜索,可能找到最优解

### 启发式的基本思想

- 定义一个评价函数,对当前搜索状态进行评估,找出一个最有希望的节点来扩展.
- 使用评估函数实际是对OPEN表进行排序(低的排在前),再从低到高扩展节点,进行搜索.

#### 例子

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\启发式搜索-八数码.PNG" style="zoom:50%;" />

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\启发式搜索-八数码-过程.PNG" style="zoom:50%;" />

#### 启发式搜索过程

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\启发式搜索目的.PNG" style="zoom:50%;" />

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\启发式搜索-图.PNG" style="zoom:50%;" />

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\启发式搜索-符号约定.PNG" style="zoom:50%;" />

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\启发式搜索-基本性质.PNG" style="zoom:50%;" />

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\启发式搜索-A算法.PNG" style="zoom:80%;" />

## A*算法与性质

在A算法中,如果满足$0\leq h(n)\leq h^{*}(n)$,则称A算法为$A^{*}$算法($h^{*}(n)$为n到目标状态的==最优路径的代价==), 则==如果某一问题有解,那么利用A*搜索算法对该问题进行搜索,则一定能搜索到解,并且一定能搜索到最优的解而结束==

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\A星算法-hn星.PNG" style="zoom:50%;" />

### 可采纳性

当一个搜索算法在最短路径存在时能保证找到它;

对任一个图,存在从S到目标的路径,如果一个搜索算法==总是==结束在一条从S到目标的最佳路径上,则称此算法是可采纳的.   可能存在一条或多条

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\A星-宽度优先..PNG" style="zoom:50%;" />

宽度优先算法相当于A*算法中h(n)=0,和f(n)=g(n)+0

### A*算法的基本性质

#### 性质一

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\A星算法-性质1.PNG" style="zoom:60%;" />

#### 性质二

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\A星算法-性质2.PNG" style="zoom:80%;" />

简洁表达:A*结束前,OPEN表中必存在$f(n)\leq f星(s)$

存在一个节点n,n在最佳路径上,
$$
\begin{aligned}
f(n)&=g(n)+h(n)\\
&=g^{*}(n)+h(n)\\
&\leq g^{*}(n)+h^{*}(n)\\
&=f^{*}(n)\\
&=f^{*}(s)
\end{aligned}
$$

#### 性质三

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\A星算法-性质3.PNG" style="zoom:50%;" />

#### 性质四

<img src="E:\研究生\研一\上半学年\人工智能原理与算法\图片\A星算法-性质4.PNG" style="zoom:50%;" />

#### 性质五

![](E:\研究生\研一\上半学年\人工智能原理与算法\图片\A星算法-性质5.PNG)

![](E:\研究生\研一\上半学年\人工智能原理与算法\图片\A星算法-性质5-证明1.PNG)

![](E:\研究生\研一\上半学年\人工智能原理与算法\图片\A星算法-性质5-证明2.PNG)

![](E:\研究生\研一\上半学年\人工智能原理与算法\图片\A星算法-性质5-证明3.PNG)

#### 性质六

![](E:\研究生\研一\上半学年\人工智能原理与算法\图片\A星算法-性质6.PNG)

![](E:\研究生\研一\上半学年\人工智能原理与算法\图片\A星算法-性质6-证明1.PNG)

![](E:\研究生\研一\上半学年\人工智能原理与算法\图片\A星算法-性质6-证明2.PNG)

#### $A^{*}$算法和启发式信息

![](E:\研究生\研一\上半学年\人工智能原理与算法\图片\A星与启发式信息.PNG)

![](E:\研究生\研一\上半学年\人工智能原理与算法\图片\A星与启发式信息2.PNG)

![](E:\研究生\研一\上半学年\人工智能原理与算法\图片\A星与启发式信息4.PNG)

p(n)的计算从 1开始到8结束,对于S(n),例如左图,8后面是3,记2.

![](E:\研究生\研一\上半学年\人工智能原理与算法\图片\A星与启发式信息3.PNG)

![](E:\研究生\研一\上半学年\人工智能原理与算法\图片\A星与启发式信息5.PNG)